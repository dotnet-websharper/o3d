% Usage

## Creating a context

In order to use WebGL, you need to create a context from a Canvas
element. Currently, WebGL contexts are called "webgl" or
"experimental-webgl" depending on the browser.

    #fsharp
    let CreateContext (canvasElement : Element) =
        let canvas = As<CanvasElement> canvasElement.Dom
        canvas.Width <- 400
        canvas.Height <- 300
        ["webgl"; "experimental-webgl"]
        |> List.tryPick (fun s ->
            let gl = As<WebGLRenderingContext> (canvas.GetContext s)
            if gl = null then None else Some gl)

This function returns a `WebGLRenderingContext option`. If it is
`None`, this means that a context could not be created.

## Passing texture data to WebGL

In WebGL, textures can receive data in several ways: 
  * From raw data (in a standard or typed array);
  * From a tag such as `<img>`, `<video>` or `<canvas>`.

In order to pass texture data from a tag, you need to use the
`Dom` attribute of the tag object:

    #fsharp
    gl.TexImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA,
                  gl.UNSIGNED_BYTE, img_tag.Dom)

If you use a `<img>` tag, you need to make sure that it has loaded
before you use it:

    #fsharp
    let MakeAndBindTexture (gl : WebGLRenderingContext) =
        Img []
        |>! Events.OnLoad (fun img ->
            let tex = gl.CreateTexture()
            gl.ActiveTexture(gl.TEXTURE0)
            gl.BindTexture(gl.TEXTURE_2D, tex)
            gl.PixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1)
            gl.TexImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA,
                          gl.UNSIGNED_BYTE, img_tag.Dom)
            // texture data is now loaded, you can now use it
        )
        |> fun img -> img -< [Attr.Src "image.png"]
        |> ignore

Note that we set the image source after the event handler, in order
to be sure that the image is not loaded yet when we set the handler.

## Animation

In order to render an animated scene, the frame needs to be updated at
regular intervals. One could use the JavaScript function `SetInterval`
for this purpose. The problem is that if an image takes longer than the
given interval to render, the following frame will start rendering while
the first one is not finished, which may cause all sorts of bugs.
Instead, you should use a new `SetTimeout` for each frame.

    #fsharp
    let rec RenderFrame () =
        // Do your rendering routines...

         // 20ms means a maximum of 50 frames per second
        JavaScript.SetTimeout RenderFrame 20
    RenderFrame ()
